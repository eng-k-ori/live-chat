# バージョンは適宜変更
FROM ruby:2.6.4
# パッケージリストを最新の状態に更新し、vimをインストールする
RUN apt-get update -qq && apt-get install -y vim

RUN mkdir /live-chat-rails
WORKDIR /live-chat-rails
COPY Gemfile /live-chat-rails/Gemfile
COPY Gemfile.lock /live-chat-rails/Gemfile.lock

# RubyGemsを最新バージョンに更新
# RUN gem update --system
# Bundlerを最新バージョンに更新
# RUN bundle update --bundler
# 2
RUN bundle install
COPY . /live-chat-rails

COPY entrypoint.sh /usr/bin/
# entrypoint.shの権限(+x:すべてのユーザーに実行権限を追加)を変更
RUN chmod +x /usr/bin/entrypoint.sh
# ENTRYPOINT:Dockerfileの中で、コンテナ起動時に実行するデフォルトのコマンドを設定
ENTRYPOINT ["entrypoint.sh"]
# 3
CMD ["rails", "server", "-b", "0.0.0.0"]

# @          @@          @@          @@          @@          @@          @@          @@          @
# 1
# apt-get update -qq && apt-get install -y vim
# apt-get update -qqパッケージリストを最新の状態に更新するコマンド。
# -qqオプションは、出力を最小限に抑えるためのもの。Dockerfileで頻繁に使われる。
# パッケージをインストールする前に最新のリストを取得することで、最新のバージョンのソフトウェアが確実にインストールされ
# るようにする。
# ------------------------------------------------------------------------------------------------
# apt-get install -y vim
# -yオプションは、すべての確認を自動的に「yes」にする
# 開発中にコンテナ内でテキストファイルを編集する必要がある場合、vimを使えるようにしておくと便利なため、これをインストール

################################################################################################
# 2
# 説明は正確だと言える。
# 手順の流れとその理由について、以下のように整理できる：
# ------------------------------------------------------------------------------------------------
# 1. **初期段階の`Gemfile`と`bundle install`**
#    - `Gemfile`にRailsのバージョンだけを記載して`bundle install`を実行することで、Railsの基本的な依存関係がインストールされる。これにより、`rails new`コマンドが実行可能な状態になる。
# ------------------------------------------------------------------------------------------------
# 2. **`rails new`でのアプリケーション生成**
#    - `rails new`コマンドを実行することで、アプリケーションのディレクトリ構造が生成され、必要なGemを含んだ新しい`Gemfile`が作成される。
# ------------------------------------------------------------------------------------------------
# 3. **二度目の`bundle install`**
#    - 新しく生成された`Gemfile`に基づいて`bundle install`を再度実行することで、アプリケーションに必要な全てのGemがインストールされる。
# ------------------------------------------------------------------------------------------------
# 4. **Dockerとの関係**
#    - Dockerのキャッシュ機能を最大限に活用するため、`Gemfile`の変更が最小限になるようにし、効率的なビルドを行うための手順となっている。初回の`bundle install`で基本的なRails環境を整え、`rails new`後に生成された新しい`Gemfile`を基に再度インストールを行うことで、キャッシュが有効に活用される。

################################################################################################
# 3
### 前提知識
# まず、`Dockerfile` で指定する `CMD` と `docker-compose.yml` で指定する `command` の優先順位を理解する必要
# がある。
# - **`CMD`**: `Dockerfile` で指定されたデフォルトのコマンド。このコマンドは、特に上書きされない場合に実行。
# - **`command`**: `docker-compose.yml` で指定されたコマンド。このコマンドは `CMD` を上書きするため、`command`
# が指定されている場合はそちらが優先されて実行される。
# また、`ENTRYPOINT` はコンテナが起動したときに最初に実行されるスクリプトやコマンドを指定する。`CMD` や `command`
# は `ENTRYPOINT` に渡される引数として動作する。
# ================================================================================================
# **`docker-compose build --no-cache`**
# - **説明**: `docker-compose build --no-cache` は、キャッシュを使用せずに新しいイメージをビルドするためのコマ
# ンド。
# - **実行されるコマンド**: このコマンド自体は、イメージをビルドするだけでコンテナを起動しない。そのため、この時点では
# `command` も `CMD` も実行されない。
# ================================================================================================
# **`docker-compose up --force-recreate`**
# - **説明**: `docker-compose up --force-recreate` は、既存のコンテナを削除して再作成し、指定されたサービスを
# 起動する。
# **実行されるコマンド**:
# - `docker-compose.yml` に `command: bash -c "rm -f tmp/pids/server.pid && bundle exec rails s -p 3000 -b '0.0.0.0'"` 
# が指定されているため、この `command` が優先されて実行される。
# - **理由**: `command` が指定されている場合、`Dockerfile` の `CMD` は無視される。
# - **`entrypoint.sh` との関連**: `entrypoint.sh` は `ENTRYPOINT` に指定されているため、コンテナが起動する際
# にまず実行される。つまり`command` で指定されたコマンドが `exec "$@"` によって実行される。
# ================================================================================================
# **`docker-compose run --rm rails`**
# - **説明**: `docker-compose run --rm rails` は、一時的に `rails` サービスを実行し、終了後にコンテナを削除
# する。
# - **実行されるコマンド**:
# - ここでも、`docker-compose.yml` に指定された `command` が実行されるため、
# `command: bash -c "rm -f tmp/pids/server.pid && bundle exec rails s -p 3000 -b '0.0.0.0'"` が実行
# される。
# - **理由**: `docker-compose run` でも `docker-compose.yml` の `command` が優先されるため、`Dockerfile`
# の `CMD` は無視される。
# - **`entrypoint.sh` との関連**: `entrypoint.sh` が`exec "$@"` によって`command` で指定されたコマンドが
# 実行される。
# ================================================================================================
# CMD ["rails", "server", "-b", "0.0.0.0"] が実行されるのはどんなコマンドの時？
# CMD ["rails", "server", "-b", "0.0.0.0"] が実行されるのは、以下のような状況の場合。
# docker-compose.yml に command が指定されていない場合: docker-compose.yml に command が設定されていなけれ
# ば、Dockerfile の CMD がデフォルトで実行される。つまり、docker-compose up や docker-compose run を実行した
# ときに command が定義されていない場合、CMD が実行される。
# ------------------------------------------------------------------------------------------------
# 直接 docker run コマンドでコンテナを起動する場合: 例えば、docker run <イメージ名> のようにコマンドを指定せずに
# 実行すると、Dockerfile の CMD が実行される。
# ------------------------------------------------------------------------------------------------
# どういう意図で記載されている？ 意図と意味
# デフォルトの動作を定義するため: CMD は、そのイメージがどのように使用されるべきかのデフォルトの動作を定義するもの。
# Railsアプリケーションの場合、通常は rails server コマンドを使ってアプリケーションサーバーを起動するので、それが
# デフォルトの動作として CMD に記載される。
# 柔軟性を持たせるため: CMD はあくまでデフォルトであり、特定の状況や必要に応じて docker-compose.yml や
# docker run コマンドで簡単に上書きできるようにするために存在する。例えば、デバッグや特別な起動オプションが必要な場
# 合に、CMD を上書きすることで対応できる。
# よって、CMD ["rails", "server", "-b", "0.0.0.0"] を設定しておくことには意味がある